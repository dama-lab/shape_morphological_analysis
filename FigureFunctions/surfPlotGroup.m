function  surfPlotGroup(targetLists, groupMeanSurf, pcGroup, vertexData)
%% Plot surface on group mean
% Ref: mial_tools/matlab/calculate_rft_grp_diff.m
%     % create model and contrast
%     [slm,contrast] = createModel(fs.data,fs.groups,fs.group_names,fs.clinical_info,template_surf);
%   
%     % call the surfstat RFT analysis
%     [result_struct.RFTgroupDiff,slm] = performRFTgroupDiff(slm,contrast,RFT_thresh,RFT_clusterCandidateThresh);
% printSurfStatResults
%
% Input:
%     groupMeanSurf: grouopMeansurf.vertex, grouopMeansurf.vertex

    %% load everything (for testing/debug)
  % read nifti
    groupMeanNii = fullfile(groupMeanDir,'/mask_manual/average_nonrigid_it_10_nonan.nii.gz');
    groupMeanVol = niftiread(groupMeanNii);
    
    %% convert vol2surf
    [groupMeanSurf.vertex, groupMeanSurf.triedge, groupMeanSurf.regions,groupMeanSurf.holes] = ...
        vol2surface(groupMeanVol);
    %% Fix mesh generated by iso2mesh by removing isolated nodes (duplicate non-manifold vertices)
    % Ref: AnalyzeToParaviewVtk.m
    [groupMeanSurf.vertex, groupMeanSurf.triedge] = meshcheckrepair(groupMeanSurf.vertex, groupMeanSurf.triedge); 

    resultMat = fullfile(surf_dir,'fullCerebellarCortex.mat');
    load(resultMat,'pcGroup');
    %% read targetlist
    targetListWtFile = fullfile(targetListDir,'TargetList_WT.txt');
    targetListTgFile = fullfile(targetListDir,'TargetList_TG.txt');

    targetListWT = readTextLines(targetListWtFile);
    targetListTG = readTextLines(targetListTgFile);
    % add am empty target to the 10 TG so that it mach with WT number (11)
    targetListTG = cat(1,targetListTG,"");

    targetLists = [targetListWT, targetListTG];

    groups = {'WT','TG'};
     
    %% %%%%%%%%%%%% Groupwise Mean %%%%%%%%%%%%%%%%
    vertexMean = groupMeanSurf.vertex;
    triedgeMean = groupMeanSurf.triedge;
    %% Find the norm of displacement for each individual to the group mean
    % vnorm Ref: mial-tools/matlab/VolSubCortShapeAnalysis/generate_norm_disp (Ref to subcortical group difference module)
    TR = triangulation(triedgeMean,vertexMean);
    vnormal = vertexNormal(TR);
    %% Visualizing PC
    pcIdIntensity = (1:size(vertexMean,1))';
    pcMean = pointCloud(vertexMean,'Intensity', pcIdIntensity);
    figure;pcshow(pcMean); % Be careful, pointCloud will also rearrange poitn orders
    %% Visualizing Surf
    surfPlot(vertexMean,triedgeMean);
    
    %% get the displacement for all the WT/TG group
    close all;
    distanceMean = [];
    distanceMatrix = cell(0);
    groups = {'WT','TG'};
%     %%
%     fig = figure;
%     % [ha, pos] = tight_subplot(3,3,[0.0, 0.03], [0, 0], [0,0]);
%     tiledlayout(3, 3);
    
    for groupID = 1:length(groups)
        %%
        targetListGroup = targetLists(:,groupID);
        distanceGroup = [];
        vertexGroup = [];
        
        for targetId = 1:length(targetListGroup)
            %% target vertex
            target = targetListGroup(targetId);
            
            if strcmp(target,''); continue; end
            
            %%
            pcTarget = pcGroup(target);
            
            %% registering target pc to group mean pc in case haven't (will randommly re-arrange the points)
            % pcshowpair(pcMean, pcTarget) % before register
            pcTarget = pcRegistration(pcTarget,pcMean);
            %pcshowpair(pcTarget, pcTargetRegistered) % after register
            
            %% Merge all point clouds (not used)
            if targetId == 1
                pcAll = pcTarget;
            else
                pcAll = pcmerge(pcAll,pcTarget,0.015);
            end
            
            %% calculate the distance 
            [distance, vertexTarget, ~, ~] = ...
                pcDistance(pcTarget, pcMean, vnormal);
            % distanceGroup = [distanceGroup; distance];
            vertexGroup = cat(3,vertexGroup,vertexTarget);
        end
        
        %% Get the groupwise mean from the rigid-registered pointClouds (works)
        vertexGroupMean = mean(vertexGroup,3);
        pcGroupMean = pointCloud(vertexGroupMean);
        %pcshow(pcGroupMean);
        % pcshowpair(pcMean,pcGroupMean);
%         [distance, vertexTarget, displacement, pcTarget, pcLocSub] = ...
%             pcDistance(pcGroupMean, pcMean, vnormal);
        
        %% Reorder pcGroupMean (can simply use:  [vertexReordered,pcLocSub] = vertexReorder(pcGroupMean.Location, vertexMean);
        [vertexLocSub,~] = knnsearch(vertexTarget, vertexMean);
        vertexReordered = vertexTarget(vertexLocSub,:);

        %% Visualize the new pcGroupMean using pcMean's triedgeMean (works)
        % figure;surfPlot(vertexReordered,triedgeMean);
        
        %% Visualizatiing the merged pointcloud (for testing only, no use)
        % pcshow(pcAll);
        
        %% calculate the group average
        distanceGroup = [];
        for targetId = 1:length(targetListGroup)
            %% target vertex
            target = targetListGroup(targetId);
            if strcmp(target,''); continue; end
            
            pcTarget = pcGroup(target);
            
            [distance, ~, ~] = ...
                vertexDistance(pcTarget.Location, vertexMean, vnormal);
            distanceGroup = [distanceGroup; distance];
        end
        distanceGroupMean = mean(distanceGroup,1);
        
        
        %% visualize the group mean
        % figure;
        % nexttile;
        % surfPlot(vertexMean, triedgeMean, distanceGroupMean,'');
        
        %%
        distanceMean = [distanceMean; distanceGroupMean];
        distanceMatrix{groupID} = distanceGroup;
        % distanceMatrix = cat(3,distanceMatrix,distanceGroup);
        
    end
    
    %% perform the statistical analysis (SurfStats)
    % Ref: mial_tools/matlab/calculate_rft_grp_diff.m
    % (Ref: http://www.math.mcgill.ca/keith/surfstat/#m-f)
%     grpMeanSurf.p = vertexMean;
%     grpMeanSurf.t = triedgeMean;
    
    % Get group and TIV
    TIVtable = readtable(TIVCsv);
    TIV = TIVtable.('TIV');
    groupLabel = TIVtable.('population');
    % Model terms
    TIVTerm = term(TIV);
    groupTerm = term(groupLabel);
    DistanceY = [distanceMatrix{1};distanceMatrix{2}];
    %% build model
    surf.coord = vertexMean';
    surf.tri = triedgeMean;
    
    M = 1 + groupTerm;
    % image(M);
    slm = SurfStatLinMod(DistanceY, M, surf);
    contrast = groupTerm.wt - groupTerm.tg;
    slm = SurfStatT(slm, contrast);
    
    %%%%%%%%% Visualization %%%%%%%%%%%%
    %% customize colormap
    colormaps = colormap('jet');
    colormaps(128,:) = [0.9,0.9,0.9];
    colormaps(129,:) = [0.9,0.9,0.9];
    
    %% colormap for p-value
    cm=[zeros(1,3);
    zeros(127,1)   (0:126)'/127   ones(127,1); ones(1,3)*0.8;
    ones(127,1)    (0:126)'/127   zeros(127,1)];
    
    %% surfPlot T
    figure; surfPlot(vertexMean, triedgeMean, slm.t,'');
    %% SurfStatViewData
    [a,cb] = SurfStatViewData(slm.t,surf)
    
    %% surfPlot p:
%     resels = SurfStatResels(slm);
%     stat_threshold(resels, length(slm.t), 1, slm.df);
    [pval, peek, clus] = SurfStatP(slm);
    SurfStatView(pval,surf)
    
    %% inflate
    surfinfl = SurfStatInflate( surf );

    
    
    %% %%%%%%%%%%%%%%% pilot test
    % sample target
    target = 'tc1_277562-ob_c';
    
    %% %%%%%%% Before rigid-registered %%%%%%
    %% Surface displacement between WT/TG groups
    surfMean = refSurf;
    vertexTarget = vertexGroup(target); 
    pcTarget = pcGroup(target);
    %% pcShowPair to check rigid displacement
    % pcshowpair(pcTarget,pointCloud(surfMean));
    
    %% Register target surface to group mean
    %% Option 1: using Matlab's internal function (already done in pcResampleGroup)
    % % find closet point on target for each vertex on mean surface
    %[surfTargetSub,surfDistanceNormTarget] = knnsearch(surfMean,surfTarget);
    % distance = (surfMean - surfTarget(surfTargetSub));
    % pcshowpair(pointCloud(refSurf),pcTarget);
    
    %% Option 2: using better point cloud classes
    % Ref: https://www.geo.tuwien.ac.at/downloads/pg/pctools/pctools.html#ICP
    % Ref: https://www.geo.tuwien.ac.at/downloads/pg/pctools/publish/pointCloudIntro/html/pointCloudIntro.html
    
    
    %% Find the norm of displacement for each individual to the group mean
    %% vnorm Ref: mial-tools/matlab/VolSubCortShapeAnalysis/generate_norm_disp (Ref to subcortical group difference module)
    TR = triangulation(tri,point);
    distance = (refSurf - pcTarget.Location);
    vnormal = vertexNormal(TR);
    displacement = transpose(dot(distance,vnormal,2));    
    
    %%
	figure;
    trisurf(TR,displacement','EdgeColor','none');
    colormap('jet'); daspect([1 1 1]);camlight; axis vis3d off;
    lighting gouraud; material shiny; % shading interp;
    
    %% plot after removing isolated nodes (beautiful!)
    figure;
    %%
    if exist('vertexData','var')
        trisurf(tri,point(:,1),point(:,2),point(:,3), vertexData, 'EdgeColor','none');
    else
        trisurf(tri,point(:,1),point(:,2),point(:,3), 'EdgeColor','none','FaceColor','r');
    end
    
    %% beautify figure
    colormap('jet'); daspect([1 1 1]);camlight; axis vis3d off;
    lighting gouraud; material shiny; shading interp;
end

